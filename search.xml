<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2.VS COde之我的settings配置]]></title>
    <url>%2F2019%2F01%2F30%2F2-VS-COde%E4%B9%8B%E6%88%91%E7%9A%84settings%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930&#123; // 为指定的语法定义配置文件或使用带有特定规则的配置文件。 &quot;emmet.syntaxProfiles&quot;: &#123; &quot;vue-html&quot;: &quot;html&quot;, &quot;vue&quot;: &quot;html&quot;, &quot;javascript&quot;: &quot;javascriptreact&quot;, &#125;, // 在jsx中使用emmet自动补全代码 &quot;emmet.triggerExpansionOnTab&quot;: true, &quot;emmet.includeLanguages&quot;: &#123; &quot;javascript&quot;: &quot;html&quot;, &#125;, // Git安装位置 &quot;git.path&quot;: &quot;D:/Program Files/Git/bin/git.exe&quot;, // 配置文件关联，比如stylus使用css智能提示 &quot;files.associations&quot;: &#123; &quot;*.styl&quot;: &quot;css&quot;, &quot;*.less&quot;: &quot;css&quot;, &quot;*.sass&quot;: &quot;css&quot;, &#125;, // 自动保存的时机 &quot;files.autoSave&quot;: &quot;onFocusChange&quot;, // 控制是否显示工作台底部状态栏中的 Twitter 反馈 (笑脸图标)。 &quot;workbench.statusBar.feedback.visible&quot;: false,&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.VS Code之常用配置文件]]></title>
    <url>%2F2019%2F01%2F30%2F1-VS-Code%E4%B9%8B%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[一、配置中文界面 Ctrl + Shift + P configure display language 修改文件：local.json 1&quot;local&quot;:&quot;zh-CN&quot; 重启VS Code 二、配置快捷键 修改文件：keyblindings.json 三、配置debugger 修改文件：launch.json 四、工作空间配置在Visual Studio Code里面有两种配置的概念，User和Workspace 。它们分别代表了两种作用域的配置概念。 User 全局 Workspace 局部 （工作空间） 配置时会生成相应的 settings.json 文件，User的配置文件存放在全局目录中，Workspace的配置文件存放在所在的工作空间 五、配置JS文件声明注释 首选项/用户代码片段 创建一个.code-snippets文件 添加自定义片段 12345678910111213 &quot;JS description&quot;: &#123; &quot;prefix&quot;: &quot;jsfile&quot;, &quot;body&quot;: [ &quot;/**&quot;, &quot;* @module $&#123;TM_FILENAME_BASE&#125;&quot;, &quot;* @author: ZHANG Jinling&quot;, &quot;* @since: $&#123;CURRENT_YEAR&#125;-$&#123;CURRENT_MONTH&#125;-$&#123;CURRENT_DATE&#125; $&#123;CURRENT_HOUR&#125;:$&#123;CURRENT_MINUTE&#125;:$&#123;CURRENT_SECOND&#125;&quot;, &quot;*/&quot;, &quot;&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Insert description.&quot;&#125; 其具体字段含义 字段 说明 prefix 前缀，即你在编辑器中输入的内容为前缀指定内容时，能够在编辑器建议中选择此片段。 body 具体文本内容，在选择此片段后，会将此数组根据 \n进行组合输出到编辑器中。 其中有部分特定的常量，可以获取输入时的部分信息，如： ${CURRENT_YEAR}:当前年份，具体字段可以见 此处 说明：在写此文章时，部分1.20.0版本增加的常量并不在上面的文档中，具体字段为： CURRENT_YEAR：年（4位数） CURRENT_YEAR_SHORT：年（2位数） CURRENT_MONTH：月 CURRENT_DATE：日 CURRENT_HOUR：小时 CURRENT_MINUTE ：分钟 CURRENT_SECOND：秒 description 描述说明，在片段说明中会显示此字段的文本内容。 六、其他常用 全局添加 git 连接 123&#123; &quot;git.path&quot;: &quot;D:/Program Files/Git/bin/git.exe&quot;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS知识梳理]]></title>
    <url>%2F2018%2F12%2F22%2FCSS%E6%80%BB%E7%BB%93%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[思维导图缩略图 CSS知识梳理 思维导图 - 待补充]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【阮一峰】React入门实例教程（学习笔记）]]></title>
    <url>%2F2018%2F11%2F05%2F%E3%80%90%E9%98%AE%E4%B8%80%E5%B3%B0%E3%80%91React%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B%E6%95%99%E7%A8%8B%EF%BC%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、JSX 语法 支持Html+JavaScript混写。 允许直接在模板中插入JavaScript变量。如果这个变量是一个数组，则会展开这个数组的所有成员。 在模板中插入数组变量时，要明确key，react的key关乎到react的dom-diff算法。react中对于dom的操作是根据生成的data-reactid进行绑定的，添加key可以保证dom结构的完整性，而不会根据react自己对dom标记的key进行重新分配。 12345678910111213let names = [&apos;Alice&apos;, &apos;Emily&apos;, &apos;Kate&apos;]; let keyid = 0; ReactDOM.render( &lt;div &#123; names.map((name) = &#123; return &lt;div key = &#123;keyid++&#125;Hello, &#123; name &#125; !&lt;/div &#125;) &#125; &lt;/div, document.getElementById(&apos;example&apos;) ); 二、组件 React 版本 16 以前： 123456# React.createClass() 用于生成一个组件类let HelloMessage = React.createClass(&#123; render: () = &#123; return &lt;h1Hello &#123; this.props.name &#125;&lt;/h1 &#125;&#125;); React 版本 16 以后： 1234567891011class HelloMessage extends React.Component&#123; render()&#123; return ( &lt;h1Hello &#123; this.props.name &#125; !&lt;/h1 ) &#125;&#125;ReactDOM.render( &lt;HelloMessage name=&quot;Eva&quot;/, document.getElementById(&quot;example&quot;)) 以上两种的区别：https://www.cnblogs.com/wonyun/p/5930333.html 所有组件都要有自己的render方法，用于输出组件。 组件类的第一个字母必须大写，否则会报错。 组件类只能包含一个顶层标签。 组件的属性可以在组件类的this.props对象上获取，比如：this.props.name。 添加组件属性，class属性需要写成className，for属性需要写成htmlFor。这是因为class和for是 JavaScript 的保留字。 三、this.props.children this.props对象的属性与组件的属性一一对应，但是this.props.children除外 this.props.children表示组件的所有子节点 this.props.children的值有三种可能： undefind —— 没有子节点 object —— 只有一个子节点 array —— 有多个子节点 我们可以用 React.Children.map 来遍历子节点 四、PropTypes 组件实例属性验证 参考 segmentfault：https://segmentfault.com/a/1190000016182458 菜鸟教程：http://www.runoob.com/react/react-props. npm安装 1npm install prop-types --save CDN引用： 1&lt;script src=&quot;https://cdn.bootcss.com/prop-types/15.6.1/prop-types.js&quot;&lt;/script&gt; 常用数据类型检测 字符串类型PropTypes.string 布尔类型PropTypes.bool 函数类型PropTypes.func 数组类型PropTypes.array 数字类型PropTypes.number 对象类型PropTypes.object 元素PropTypes.element 传入任何东西都可以PropTypes.node 选择特定值PropTypes.oneOf([‘是’, ‘否’, “是否”]) 选择诸多类型中的一种（任意类型）PropTypes.oneOfType 实例：PropTypes静态类型校验 12345678910111213141516class MyTitle extends React.Component &#123; render() &#123; return &lt;div&#123;this.props.title&#125;&lt;/div; &#125;&#125;MyTitle.propTypes = &#123; title: PropTypes.string.isRequired,&#125;;let data = 123;ReactDOM.render( &lt;MyTitle title=&#123;data&#125;/, document.getElementById(&quot;example&quot;))// =&gt; Warning: Failed prop type: Invalid prop `title` of type `number` supplied to `MyTitle`, expected `string`. 实例：设置组件属性默认值 12345678910111213class MyTitle extends React.Component &#123; render() &#123; return &lt;h1&#123;this.props.title&#125;&lt;/h1; &#125;&#125;MyTitle.defaultProps = &#123; title: &apos;defaultTitle&apos;,&#125;;ReactDOM.render( &lt;MyTitle/, document.getElementById(&quot;example&quot;)) 五、ref 属性获取真实的DOM节点 由于this.refs.[refName]属性获取的是真实的DOM节点，所以必须等到虚拟DOM插入文档后才能使用这个属性 下面实例中，要保证真实DOM发生在事件之后，才能读取到this.refs.[refName]属性 123456789101112131415161718class MyComponent extends React.Component&#123; handleClick = () = &#123; this.refs.myTextInput.focus(); &#125;; render = () = &#123; return ( &lt;div &lt;input type=&quot;text&quot; ref=&quot;myTextInput&quot;/ &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123;this.handleClick&#125;/ &lt;/div ) &#125;;&#125;ReactDOM.render( &lt;MyComponent/, document.getElementById(&apos;example&apos;)) 六、this.state 阮一峰教程中使用了getInitialState方法，该方法只能与CreateClass一起使用 使用React.Component时，需要搭配constructor this.setState方法不能直接写在constructor中 只要组件存在constructor，就必须写super，否则this.props将是未定义 两者的具体区别请对照阮一峰教程和React官方文档 123456789101112131415161718192021222324class LikeButton extends React.Component&#123; constructor(props) &#123; super(props); this.state = &#123; liked: false &#125;; this.handleClick = this.handleClick.bind(this); &#125; handleClick()&#123; this.setState(&#123; liked: !this.state.liked &#125;) &#125;; render()&#123; let text = this.state.liked ? &apos;like&apos; : &apos;have not liked&apos;; return ( &lt;p onClick=&#123;this.handleClick&#125; You &#123;text&#125; this. Click to toggle. &lt;/p ) &#125;&#125;ReactDOM.render( &lt;LikeButton/, document.getElementById(&apos;example&apos;)) 七、表单 表单需要用户和组件互动，所以不能用this.props直接读取 textarea 元素、select元素、radio元素都属于这种情况 要定义一个 onChange 事件的回调函数，通过 event.target.value 读取用户输入的值 1234567891011121314151617181920212223class Input extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;value: &quot;Hello!&quot;&#125;; this.handleChange = this.handleChange.bind(this); &#125; handleChange(event)&#123; this.setState(&#123; value: event.target.value &#125;) &#125; render()&#123; let value = this.state.value; return ( &lt;div &lt;input type=&quot;text&quot; value=&#123; value &#125; onChange=&#123; this.handleChange &#125;/ &lt;p&#123; value &#125;&lt;/p &lt;/div ) &#125;&#125;ReactDOM.render( &lt;Input/, document.getElementById(&quot;example&quot;)) 八、组件的生命周期 三种状态 Mounting：已插入真实DOM Updating：正在被重新渲染 Unmounting：已移出真实DOM 五种处理函数 componentWillMount()：在这个函数中，不可以调用setState来修改状态 componentDidMount()：①.ajax可以再这里调用，返回数据setState后组件会重新渲染；②.可以通过this.refs来访问真实DOM componentWillUpdate(object nextProps, object nextState) componentDidUpdate(object prevProps, object prevState) componentWillUnmount() 两种特殊状态 componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用，该函数只监听props的改变，this.setState不会触发这个函数 shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用，这个函数只返回true或false，表示组件是否需要更新 1234567891011121314151617181920212223242526272829class Hello extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;opacity: 1.0&#125;; &#125; componentDidMount()&#123; this.timer = setInterval(function () &#123; let opacity = this.state.opacity; opacity -= .01; if (opacity &lt; 0.1)&#123; opacity = 1.0 &#125; this.setState(&#123; opacity: opacity &#125;) &#125;.bind(this), 20) &#125; render()&#123; return ( &lt;div style=&#123;&#123; opacity: this.state.opacity &#125;&#125; Hello &#123; this.props.name &#125; &lt;/div ) &#125;&#125;ReactDOM.render( &lt;Hello name=&quot;world&quot;/, document.getElementById(&apos;example&apos;)) 九、Ajax 我们通常在componentDidMount周期中调用Ajax请求，成功后再用setState方法重新渲染数据 阮一峰老师的案例中使用的isMouted()方法，在React的ES6语法中已经废弃 1234567891011121314151617181920212223242526272829303132class UserGist extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; username: &apos;&apos;, lastGistUrl: &apos;&apos; &#125; &#125; componentDidMount()&#123; this.serverReq = $.get(this.props.source, function (result) &#123; let lastGist = result[1]; this.setState(&#123; username: lastGist.owner.login, lastGistUrl: lastGist.html_url &#125;) &#125;.bind(this)) &#125; componentWillUnmount() &#123; this.serverReq.abort(); &#125; render()&#123; return ( &lt;div &#123; this.state.username &#125;&apos;s last gist is &lt;a href=&#123; this.state.lastGistUrl &#125;here&lt;/a &lt;/div ) &#125;&#125;ReactDOM.render( &lt;UserGist source=&quot;https://api.github.com/users/octocat/gists&quot;/, document.getElementById(&apos;example&apos;)) 参考文章 React入门实例教程 —— 阮一峰 React的生命周期到底是怎么一回事？]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS兼容问题总结整理]]></title>
    <url>%2F2018%2F09%2F12%2FCSS%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[网页的浏览器兼容性，指网页在各种浏览器上的显示效果尽量保持一致的状态。 兼容性起因浏览器大战 兼容性的重要性 网站做好了浏览器兼容，能够让网站在不同的浏览器下都正常显示 浏览器兼容能够抓住更多的网站访客 浏览器兼容能够给客户更好的体验 目前常见的兼容方案 IE条件注释法 123&lt;!--[if IE]&gt; 这段文字只在IE浏览器显示&lt;![endif]--&gt; 类内属性前缀法 字符 示例 说明 _ _color:red; IE6 * *color:green; IE6/7 \9 color:yellow\9; IE6/IE7/IE8/IE9/IE10都生效 \0 color:blue\9; IE8/IE9/IE10都生效 \9\0 color:purple\9; 只对IE9/IE10生效 浏览器前缀法 内核 主要代表的浏览器 前缀 Trident IE浏览器 -ms Gecko Firefox -moz Presto Opera -o Webkit Chrome和Safari -webkit 通过meta标签来控制 国内浏览器多为双核浏览器（360浏览器等），即webkit+IE，兼容起来实在费神，我们可以使用定义meta标签强制浏览器使用某种内核打开页面： 123456//若页面需默认用极速核，增加标签：&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; //若页面需默认用ie兼容内核，增加标签：&lt;meta name=&quot;renderer&quot; content=&quot;ie-comp&quot;&gt; // 若页面需默认用ie标准内核，增加标签：&lt;meta name=&quot;renderer&quot; content=&quot;ie-stand&quot;&gt; 我在工作中遇到的部分兼容性问题 浏览器默认margin和padding各有不同 reset.css重置全局样式 1234&#123; margin:0; padding:0;&#125; Chrome中文界面下小于12px的文本会强制按照12px显示 可使用CSS属性webkit-text-size-adjust 1&#123; webkit-text-size-adjust:none; &#125; 漏写DTD声明在IE中会触发浏览器的怪异模式（FireFox中仍会按照标准模式来解析） 一定要加DTD声明 IE和FireFox中相邻DIV上下margin会重合，重合时按照绝对值较大的margin进行展示 养成固定习惯，尽量只用margin-top或者margin-bottom中的一个 透明度： 1234&#123; opacity: 0.6 ; filter: alpha(opacity=60)；&#125; 所有浏览器下，p标签中间加载块元素都会被分解成两个p元素 不要在p标签中间加块级元素 a标签在访问后，各状态的样式会混乱掉 4各伪类的顺序按照：L-V-H-A 渐变的兼容 使用filter滤镜（带透明度的渐变，在部分低版本浏览器上会失去透明度） 123456789.gradient&#123; width:300px; height:150px; filter:alpha(opacity=100 finishopacity=0 style=1 startx=0,starty=0,finishx=100,finishy=0) progid:DXImageTransform.Microsoft.gradient(startcolorstr=#483F96,endcolorstr=#fff,gradientType=1); -ms-filter:alpha(opacity=100 finishopacity=0 style=1 startx=0,starty=0,finishx=100,finishy=0) progid:DXImageTransform.Microsoft.gradient(startcolorstr=#483F96,endcolorstr=#fff,gradientType=1);/*IE8*/ background:red; /* 一些不支持背景渐变的浏览器 */ background:-moz-linear-gradient(top, red, rgba(0, 0, 255, 0.5)); background:-webkit-gradient(linear, 0 0, 0 bottom, from(#ff0000), to(rgba(0, 0, 255, 0.5)));&#125; 360浏览器极速模式和兼容模式下产生的差异 1&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; a标签使用来绝对定位后，锚点会失效 锚点连接不要使用绝对定位 乱入两条js的 IE下可以用获取常规属性的方法来获取自定义属性，也可以用getAttribute()；FireFox中只能使用getAttribute()获取自定义属性 统一使用getAttribute(); IE下，event对象只有x/y属性；FireFox下，只有pageX/pageY属性 使用条件注释语句 &lt;!--[if It IE 9]&gt; &lt;script src=&quot;http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js &quot;&gt;&lt;/script&gt; &lt;![end if]--&gt; 参考文章 浏览器兼容性-维基百科 史上最全的CSS hack方式一览]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>meta</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[媒体查询（@media）]]></title>
    <url>%2F2018%2F08%2F10%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%EF%BC%88-media%EF%BC%89%2F</url>
    <content type="text"><![CDATA[媒体查询是可以更精确的作用于不同媒介类型，是实现响应式布局/自适应的一种很好的方法。随着移动端的普及变得越来越重要。 语法123@media mediatype and|not|only (media feature) &#123; CSS-Code;&#125; 在使用媒体查询之前，需要设置好&lt;meta>标签：1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1,minmum-scale=1,maxmum-scale=1,user-scalable=no&quot;&gt; Viewport 属性名 备注 width 设置layout viewport 的宽度，为一个正整数，使用字符串”width-device”表示设备宽度 height 设置layout viewport 的高度，这个属性对我们并不重要，很少使用 initial-scale 设置页面的初始缩放值，为一个数字，可以带小数 minimum-scale 允许用户的最小缩放值，为一个数字，可以带小数 maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数 user-scalable 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许 - - target-densitydpi(安卓特有) 值可以为一个数值或 high-dpi 、 medium-dpi、 low-dpi、 device-dpi 这几个字符串中的一个 @media常用方式 用min-width时，小的放上面大的在下面： 12345@media (min-width: 768px)&#123; //&gt;=768的设备 &#125;@media (min-width: 992px)&#123; //&gt;=992的设备 &#125;@media (min-width: 1200)&#123; //&gt;=1200的设备 &#125; 用max-width那么就是大的在上面，小的在下面： 12345@media (max-width: 1199)&#123; //&lt;=1199的设备 &#125;@media (max-width: 991px)&#123; //&lt;=991的设备 &#125;@media (max-width: 767px)&#123; //&lt;=768的设备 &#125; 混合应用： 123456789@media media screen and (min-width:1200px) &#123;&#125;@media media screen and (min-width: 960px) and (max-width: 1199px) &#123;...&#125;@media screen and (min-width: 768px) and (max-width: 959px) &#123;...&#125;@media only screen and (min-width: 480px) and (max-width: 767px) &#123;...&#125;@media only screen and (max-width: 479px) &#123;...&#125; @media常用媒体尺寸 方案推荐(移动端+PC)12345678910111213141516@media screen and (min-width: 320px) &#123;html&#123;font-size:50px;&#125;&#125;@media screen and (min-width: 360px) &#123;html&#123;font-size:56.25px;&#125;&#125;@media screen and (min-width: 375px) &#123;html&#123;font-size:58.59375px;&#125;&#125;@media screen and (min-width: 400px) &#123;html&#123;font-size:62.5px;&#125;&#125;@media screen and (min-width: 414px) &#123;html&#123;font-size:64.6875px;&#125;&#125;@media screen and (min-width: 440px) &#123;html&#123;font-size:68.75px;&#125;&#125;@media screen and (min-width: 480px) &#123;html&#123;font-size:75px;&#125;&#125;@media screen and (min-width: 520px) &#123;html&#123;font-size:81.25px;&#125;&#125;@media screen and (min-width: 560px) &#123;html&#123;font-size:87.5px;&#125;&#125;@media screen and (min-width: 600px) &#123;html&#123;font-size:93.75px;&#125;&#125;@media screen and (min-width: 640px) &#123;html&#123;font-size:100px;&#125;&#125;@media screen and (min-width: 680px) &#123;html&#123;font-size:106.25px;&#125;&#125;@media screen and (min-width: 720px) &#123;html&#123;font-size:112.5px;&#125;&#125;@media screen and (min-width: 760px) &#123;html&#123;font-size:118.75px;&#125;&#125;@media screen and (min-width: 800px) &#123;html&#123;font-size:125px;&#125;&#125;@media screen and (min-width: 960px) &#123;html&#123;font-size:150px;&#125;&#125; 参考文章响应式设计媒体查询尺寸分界点一览表@media响应式媒介尺寸@media 最全机型]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>meta</tag>
        <tag>media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js 知识梳理]]></title>
    <url>%2F2018%2F08%2F07%2FVue-js-%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>思维导图</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端学习路径——整理自Github Roadmap]]></title>
    <url>%2F2018%2F07%2F21%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E8%B7%AF%E5%BE%84%E2%80%94%E2%80%94%E6%95%B4%E7%90%86%E8%87%AAGithub-Roadmap%2F</url>
    <content type="text"><![CDATA[参考文章 https://github.com/kamranahmedse/developer-roadmap]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + github 搭建个人博客]]></title>
    <url>%2F2018%2F07%2F14%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[博客搭建过程前置要求：安装Node.js和Git Node.js 安装配置 | 菜鸟教程 Git - 安装 Git 1.在Github上创建一个仓库在Github上创建一个仓库（New repositor），并开启Github Pages： 2.git clone 项目到本地123git clone ...git remote add origin git@github.com:zhangjinling1993/zhangjinling1993.github.io.git 3.安装Hexo在本地仓库目录下： 12345678910npm install hexo-cli -g// 初始化hexohexo initnpm install// 生成博客页面并启动本地服务器hexo ghexo server 创建一篇文章： 12hexo new &quot;文章名称&quot;hexo new page &quot;页面名称&quot; hexo new后再执行一次hexo g hexo server 4.使用Hexo deploy部署到Github 首先要安装一个拓展 123npm install hexo-deployer-git --save// 这里安装时出现了问题，可以使用淘宝镜像cnpm重新尝试安装 编辑blog目录下_config.yml文件 1234deploy: type: git repo: git@github.com:zhangjinling/zhangjinling1993.github.io branch: master 注意：这里repo:git@github.com:zhangjinling/zhangjinling1993.github.io的地址要与Github origin地址相符 5.SSH Keys的设置 生成公钥 首先，在Git bash里输入 12345678910111213cd ~/.sshmkdir key_backupcp id_rsa* key_backuprm id_rsa* // 以上三步为备份和移除原来的SSH key设置ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; // 生成新的key文件,邮箱地址填你的Github地址// Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;// 接下来会让你输入密码 添加公钥到Github账号中 进入Github首页，账号中心，进入Setting页面 找到系统当前用户目录下C:\Users\用户名\ .ssh id_rsa.pub文件以文本方式打开。打开之后全部复制到key中 注意：用文本打开后，直接全选复制，不要错漏空格等符号 测试是否设置成功 1ssh -T git@github.com 成功会显示： 12345678910111213141516Your identification has been saved in /c/Users/SC/.ssh/id_rsa.Your public key has been saved in /c/Users/SC/.ssh/id_rsa.pub.The key fingerprint is:SHA256:/CSPEssyw7Cjpe9LOwua/UBarfnS2cIWJFoqdfCZNak 710737179@qq.comThe key&apos;s randomart image is:+---[RSA 2048]----+| . || . + || o = . || +.E . || =++. . S . ||++ *.. o * ||+ Oo=++ . o ||.Oo=*+.. ||=oBBo. |+----[SHA256]-----+ 设置你的账号信息 12git config --global user.name &quot;zhangjinling1993&quot;git config --global user.email &quot;710737179@qq.com&quot; 注意：这里是必须设置的，不得忽略，且用户名要与Github上的用户名一致，如果Github没有设置的最好设置一下，这里会将Hexo与Github page联系起来，有可能会影响后面hexo d的结果 执行hexo d 12345678910INFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...INFO Copying files from extend dirs...[master bc70590] Site updated: 2018-07-17 12:42:44 3 files changed, 7 insertions(+), 7 deletions(-)Branch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;git@github.com:zhangjinling1993/zhangjinling1993.github.io.git&apos;.To github.com:zhangjinling1993/zhangjinling1993.github.io.git 1aa90f4..bc70590 HEAD -&gt; masterINFO Deploy done: git 至此，我们的博客已成功部署到github，打开链接https://***.github.io/就可以看到啦！ 6.踩过的坑…①.git hexo Error: git@github.com: Permission denied (publickey). 12345手动删除.deploy_git文件，重新hexo deploy一次or重新设置一次公钥 ②.fatal: The remote end hung up unexpectedly 1git config http.postBuffer 524288000 ③.MD插入图片 1.首先确认_config.yml 中有 post_asset_folder:true。 2.在hexo的目录下执行安装插件hexo-asset-image，在目录下执行 npm install hexo-asset-image –save 3.安装后重新运行命令 hexo new “”， Hexo会自动建立一个与文章同名的文件夹 参考文章 我是如何利用Github Pages搭建起我的博客，细数一路的坑 手把手教你使用Hexo + Github Pages搭建个人独立博客 使用Hexo+Github一步步搭建属于自己的博客（基础） hexo博客图片问题]]></content>
      <categories>
        <category>经验总结</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F13%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
